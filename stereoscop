#!/usr/bin/env python

#DEPENDS:
# PIL
# imagemagick
# PIL-imagetk (python-imaging-tk in RPM)
import sys
import os
import subprocess
from PIL import Image
import logging

class SafeError(RuntimeError): pass

class Stereo(object):
	default_suffix = 'out'
	dest = None

	def __init__(self, left, right, basename):
		self.left = left
		self.right = right
		self.basename = basename
	
	@classmethod
	def from_single(cls, filename):
		img = Image.open(filename)
		width, height = img.size
		single_width = width // 2
		middle_bit = width - (2*single_width)
		left = img.copy().crop((0, 0, single_width, height))
		right = img.copy().crop((single_width+middle_bit, 0, width, height))
		instance = cls(left, right, os.path.basename(filename))
		instance.merge()
		return instance

	@classmethod
	def from_pair(cls, left_filename, right_filename):
		left = Image.open(left_filename)
		right = Image.open(left_filename)
		instance = cls(left, right, os.path.basename(left_filename))
		instance.split()
		return instance

	def copy(self):
		return type(self)(self.left, self.right, self.basename)
	
	def swap(self, opts=None):
		self.left, self.right = self.right, self.left
	
	def merge(self, opts=None):
		def render():
			left = self.left.copy()
			right = self.right.copy()
			lw, lh = left.size
			rw, rh = right.size
			assert lh == rh
			logging.debug("created image %rx%r to house %rx%r and %rx%r images" % (
				lw + rw, lh, lw, lh, rw, rh))
			final = Image.new(left.mode, (lw + rw, lh))
			final.paste(left, (0,0))
			final.paste(right, (lw, 0))
			return final
		self.outputs = [Output(path=self.add_suffix("out"), render=render)]

	def add_suffix(self, suffix):
		base, ext = os.path.splitext(self.basename)
		if self.dest:
			base = os.path.join(self.dest, base)
		return "%s-%s%s"% (base, suffix, ext)
	
	def crop_axis(self, points, percent, sign):
		a, b = points
		size = b - a
		assert size > 0
		diff = int((size * (percent / 100.0)))
		diff *= sign
		if diff == 0: return points
		sign = -1 if diff < 0 else 1
		if sign < 0:
			b += diff
		else:
			a += diff
		return (a,b)

	def slice(self,percent):
		def slice(sign, img):
			w,h = img.size
			left, top, right, bottom = 0, 0, w, h
			left, right = self.crop_axis(points=(0, w), percent=percent, sign=sign)
			return img.crop((left, top, right, bottom))
		self.left = slice(-1, self.left)
		self.right = slice(1, self.right)
	
	def align(self, percent):
		def slice(sign, img):
			w,h = img.size
			left, top, right, bottom = 0, 0, w, h
			top, bottom = self.crop_axis(points=(0, h), percent=percent, sign=sign)
			return img.crop((left, top, right, bottom))
		self.left = slice(-1, self.left)
		self.right = slice(1, self.right)


	def split(self, opts=None):
		left = Output(path=self.add_suffix('left'), render=lambda: self.left)
		right = Output(path=self.add_suffix('right'), render=lambda: self.right)
		self.outputs = [left, right]

	def squash(self, opts=None):
		def resize(img):
			(w, h) = img.size
			new_size = (w, h / 2)
			return img.resize(new_size, Image.ANTIALIAS)
		self.left, self.right = map(resize, [self.left, self.right])
	
	def animate(self, opts):
		resize = getattr(opts, 'resize', None)
		delay = getattr(opts, 'delay', None)
		gif = AnimatedOuptut(stereo=self, path=self.add_suffix('anim') +'.gif', resize=resize, delay=delay)
		self.outputs = [gif]
	
	def save(self, conflict_resolver):
		for output in self.outputs:
			output.save(conflict_resolver)
	
	def __repr__(self):
		return "<Image from %s with left=%r and right=%r>" % (self.basename, self.left, self.right)

class ConflictResolver(object):
	REPLACE = object()
	ABORT = object()
	IGNORE = object()

	@classmethod
	def always(cls, response):
		return cls(response_fn = lambda *a: response)

	@classmethod
	def prompt(cls):
		def handle(path):
			if handle.always:
				return handle.always
			response = raw_input("\n%s already exists.\nOverwrite it? [(y)es / (N)o / replace (a)ll / (s)kip existing ] " % (path,))
			print
			response = response.lower().strip()
			if response == 'y':
				return ConflictResolver.REPLACE
			if response == 'a':
				handle.always = ConflictResolver.REPLACE
				return handle.always
			if response == 's':
				handle.always = ConflictResolver.IGNORE
				return handle.always
			else:
				return ConflictResolver.ABORT
		handle.always = None
		return cls(handle)

	def __init__(self, response_fn):
		self.resolve = response_fn

def resolve_path_clash(path, conflict_resolver):
	if os.path.exists(path):
		response = conflict_resolver.resolve(path)
		if response is ConflictResolver.REPLACE:
			os.remove(path)
		elif response is ConflictResolver.ABORT:
			raise RuntimeError("path %r already exists!" % (path,))
		elif response is ConflictResolver.IGNORE:
			return
		else:
			raise RuntimeError("Unknown response!")

class Output(object):
	def __init__(self, path, render):
		self.path = path
		self.render = render

	def save(self, conflict_resolver):
		img = self.render()
		resolve_path_clash(self.path, conflict_resolver)
		img.save(self.path)
	
class AnimatedOuptut(object):
	def __init__(self, stereo, path, resize=None, delay=None):
		self.path = path
		self.stereo = stereo
		self.resize = resize
		self.delay = delay
	
	def save(self, conflict_resolver):
		self.stereo.split()
		self.stereo.save(conflict_resolver = ConflictResolver.always(ConflictResolver.IGNORE))
		paths = [output.path for output in self.stereo.outputs]
		cmd = ['convert', '-delay', self.delay or '15', '-loop', '0']
		if self.resize:
			cmd.extend(['-resize', self.resize])
		cmd.extend(paths)
		cmd.append(self.path)
		resolve_path_clash(self.path, conflict_resolver)
		subprocess.check_call(cmd)

class Gui(object):
	def __init__(self, image, opts):
		self.image = image
		self.opts = opts
		self.slice = 0
		self.align = 0
		self.approved = False
	
	def display(self):
		from PIL import ImageTk
		image = self.update(self.image.copy())
		left, right = image.left, image.right
		blended = Image.blend(left, right, 0.5)
		blended.thumbnail((600,400))

		tk_img = ImageTk.PhotoImage(blended)
		self.label.configure(image = tk_img)
		self.label.image = tk_img
		self.label.update()
	
	def update(self, image):
		image.slice(self.slice)
		image.align(self.align)
		return image

	def run(self):
		import Tkinter
		def quit(event):
			event.widget.quit()

		def accept(event):
			logging.debug("applying GUI changes to real image...")
			self.update(self.image)
			self.approved = True
			quit(event)

		root = Tkinter.Tk()
		root.resizable(width=Tkinter.FALSE, height=Tkinter.FALSE)

		def align(amount):
			def action(*ignored):
				self.align += amount
				self.display()
			return action

		def slice(amount):
			def action(*ignored):
				self.slice += amount
				self.display()
			return action

		root.bind('<Escape>', quit)
		root.bind('<Return>', accept)

		def bind_arrows(up, down, left, right):
			just = lambda x: "<%s>" % (x,)
			shift = lambda x: just(x.upper()) if len(x) == 1 else "<Shift-%s>" % (x,)
			root.bind(just(up), align(1))
			root.bind(just(down), align(-1))
			root.bind(shift(up), align(0.1))
			root.bind(shift(down), align(-0.1))

			root.bind(just(left), slice(1))
			root.bind(just(right), slice(-1))
			root.bind(shift(left), slice(0.1))
			root.bind(shift(right), slice(-0.1))

		bind_arrows('Up','Down','Left','Right')
		bind_arrows('j','k','l','h')

		self.label = Tkinter.Label(root)
		self.label.pack()
		self.display()
		root.title(self.image.basename)
		root.mainloop()
		if not self.approved:
			raise SafeError("Cancelled.")

def main():
	from optparse import OptionParser
	p = OptionParser()
	p.add_option('-v', '--verbose', action='store_true')
	p.add_option('-i', '--input', help='input image (pre-merged)')
	p.add_option('-l', '--left', help='inptut image (left)')
	p.add_option('-r', '--right', help='inptut image (right)')
	p.add_option('--suffix')
	p.add_option('-o', '--dest')
	p.add_option('-f', '--force', help='replace files without asking', action='store_true')
	p.add_option('--squash', action='append_const', const='squash',  dest='actions', default=[], help='squash half vertically')
	p.add_option('--split', action='append_const',  const='split',   dest='actions', help='split into left & right')
	p.add_option('--merge', action='append_const',  const='merge',   dest='actions', help='merge left & right images')
	p.add_option('--swap', action='append_const',   const='swap',    dest='actions', help='swap left & right')
	p.add_option('--animate', action='append_const',const='animate', dest='actions', help='make animated gif')
	p.add_option('-g', '--gui', help='modify slice / align interactively', action='store_true')
	p.add_option('--resize', help='(animation only) resize image to fit in rect (e.g "200x120")')
	p.add_option('--size', dest='resize', help='alias for --resize')
	opts, args = p.parse_args()

	logging.basicConfig(level=logging.DEBUG if opts.verbose else logging.INFO, format="%(message)s")

	if opts.suffix:
		Stereo.default_suffix = opts.suffix
	if opts.dest:
		if not os.path.exists(opts.dest):
			logging.debug("creating %s" % (opts.dest,))
			os.makedirs(opts.dest)
		Stereo.dest = opts.dest

	conflict_resolver = ConflictResolver.prompt()
	if opts.force:
		conflict_resolver = ConflictResolver.always(ConflictResolver.REPLACE)
	#TODO: use a graphical conflict resolver for --gui

	def process(image):
		logging.info("Processing %s" % image.basename)
		for action in opts.actions:
			logging.debug("performing action: %s" % (action,))
			getattr(image, action)(opts)
			logging.debug("image -> %r" % (image,))
		if opts.gui:
			Gui(image, opts).run()
		image.save(conflict_resolver = conflict_resolver)

	if opts.left and opts.right:
		assert opts.left and opts.right
		process(Stereo.from_pair(opts.left, opts.right))
	else:
		assert not (opts.left or opts.right)
		for file in args or [opts.input]:
			process(Stereo.from_single(file))
	
	assert len(opts.actions) > 0, "Please provide at least one action!"

if __name__ == '__main__':
	try:
		sys.exit(main())
	except (SafeError), e:
		print >> sys.stderr, e
		sys.exit(1)
	except (KeyboardInterrupt, EOFError):
		sys.exit(1)


