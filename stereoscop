#!/usr/bin/env python

import sys
import os
import subprocess
from PIL import Image, ImageOps
import logging
import numpy
import tempfile

class SafeError(RuntimeError): pass

class Stereo(object):
	suffix = 'out'
	dest = None

	def __init__(self, left, right, basename):
		self.left = left
		self.right = right
		self.basename = basename
	
	@classmethod
	def from_single(cls, filename):
		img = Image.open(filename)
		width, height = img.size
		single_width = width // 2
		middle_bit = width - (2*single_width)
		left = img.copy().crop((0, 0, single_width, height))
		right = img.copy().crop((single_width+middle_bit, 0, width, height))
		instance = cls(left, right, os.path.basename(filename))
		instance.merge()
		return instance

	@classmethod
	def from_pair(cls, left_filename, right_filename):
		left = Image.open(left_filename)
		right = Image.open(left_filename)
		instance = cls(left, right, os.path.basename(left_filename))
		instance.split()
		return instance

	def copy(self):
		return type(self)(self.left, self.right, self.basename)
	
	def swap(self, opts=None):
		self.left, self.right = self.right, self.left
	
	def merge(self, opts=None):
		def render():
			left = self.left.copy()
			right = self.right.copy()
			lw, lh = left.size
			rw, rh = right.size
			assert lh == rh
			logging.debug("created image %rx%r to house %rx%r and %rx%r images" % (
				lw + rw, lh, lw, lh, rw, rh))
			final = Image.new(left.mode, (lw + rw, lh))
			final.paste(left, (0,0))
			final.paste(right, (lw, 0))
			return final
		self.outputs = [Output(path=self.add_suffix(), render=render)]

	def add_suffix(self, *suffixes):
		base, ext = os.path.splitext(self.basename)
		if self.dest:
			base = os.path.join(self.dest, base)
		return "%s-%s%s"% (base, "-".join([self.suffix] + list(suffixes)), ext)
	
	def crop_axis(self, points, percent, sign):
		a, b = points
		size = b - a
		assert size > 0
		diff = int((size * (percent / 100.0)))
		diff *= sign
		if diff == 0: return points
		sign = -1 if diff < 0 else 1
		if sign < 0:
			b += diff
		else:
			a += diff
		return (a,b)

	def slice(self,percent):
		def slice(sign, img):
			w,h = img.size
			left, top, right, bottom = 0, 0, w, h
			left, right = self.crop_axis(points=(0, w), percent=percent, sign=sign)
			return img.crop((left, top, right, bottom))
		self.left = slice(-1, self.left)
		self.right = slice(1, self.right)
	
	def align(self, percent):
		def slice(sign, img):
			w,h = img.size
			left, top, right, bottom = 0, 0, w, h
			top, bottom = self.crop_axis(points=(0, h), percent=percent, sign=sign)
			return img.crop((left, top, right, bottom))
		self.left = slice(-1, self.left)
		self.right = slice(1, self.right)


	def split(self, opts=None):
		left = Output(path=self.add_suffix('left'), render=lambda: self.left)
		right = Output(path=self.add_suffix('right'), render=lambda: self.right)
		self.outputs = [left, right]

	def squash(self, opts=None):
		def resize(img):
			(w, h) = img.size
			new_size = (w, h / 2)
			return img.resize(new_size, Image.ANTIALIAS)
		self.left, self.right = map(resize, [self.left, self.right])
	
	def match(self, opts=None):
		# http://en.wikipedia.org/wiki/Histogram_matching
		size = 256
		def chunk(l):
			for i in xrange(0, len(l), size):
				endpoint = i+size
				yield l[i:i+size]
			assert len(l) == endpoint # make sure chunking was complete and exhaustive

		def find_closest_idx(target, items):
			# items MUST be a monotonically increasing sequence
			last_value = None
			for i, value in enumerate(items):
				if value > target:
					if last_value is None or abs(target - value) < abs(target - last_value):
						return i
					else:
						return i - 1
				last_value = value
			return i

		def new_channel_mappings():
			h1 = chunk(self.left.histogram())
			h2 = chunk(self.right.histogram())
			for (left, right) in zip(h1, h2):
				left_hist = numpy.cumsum(left)
				right_hist = numpy.cumsum(right)

				def new_level(level):
					value_in_left = left_hist[level]
					return find_closest_idx(value_in_left, right_hist)
				yield map(new_level, range(0, size))

		r, g, b = new_channel_mappings()
		combined_table = r + g + b
		self.left = self.left.point(combined_table)

	def equalize(self, opts=None):
		self.left, self.right = map(ImageOps.equalize, (self.left, self.right))
	
	#TODO: PythonMagick?
	def animate(self, opts):
		resize = getattr(opts, 'resize', None)
		delay = getattr(opts, 'delay', None)
		gif = AnimatedOuptut(stereo=self, path=self.add_suffix() +'.gif', resize=resize, delay=delay)
		self.outputs = [gif]
	
	def save(self, conflict_resolver):
		for output in self.outputs:
			output.save(conflict_resolver)
	
	def __repr__(self):
		return "<Image from %s with left=%r and right=%r>" % (self.basename, self.left, self.right)

class ConflictResolver(object):
	REPLACE = object()
	ABORT = object()
	IGNORE = object()

	@classmethod
	def always(cls, response):
		return cls(response_fn = lambda *a: response)

	@classmethod
	def prompt(cls):
		def handle(path):
			if handle.always:
				return handle.always
			response = raw_input("\n%s already exists.\nOverwrite it? [(y)es / (N)o / replace (a)ll / (s)kip existing ] " % (path,))
			print
			response = response.lower().strip()
			if response == 'y':
				return ConflictResolver.REPLACE
			if response == 'a':
				handle.always = ConflictResolver.REPLACE
				return handle.always
			if response == 's':
				handle.always = ConflictResolver.IGNORE
				return handle.always
			else:
				return ConflictResolver.ABORT
		handle.always = None
		return cls(handle)

	def __init__(self, response_fn):
		self.resolve = response_fn

def resolve_path_clash(path, conflict_resolver):
	if os.path.exists(path):
		response = conflict_resolver.resolve(path)
		if response is ConflictResolver.REPLACE:
			os.remove(path)
		elif response is ConflictResolver.ABORT:
			raise RuntimeError("path %r already exists!" % (path,))
		elif response is ConflictResolver.IGNORE:
			return
		else:
			raise RuntimeError("Unknown response!")

class Output(object):
	def __init__(self, path, render):
		self.path = path
		self.render = render
	
	def override_path(self, path):
		#TODO: copy ext!
		self.path = path

	def save(self, conflict_resolver):
		img = self.render()
		resolve_path_clash(self.path, conflict_resolver)
		img.save(self.path)
	
class AnimatedOuptut(object):
	def __init__(self, stereo, path, resize=None, delay=None):
		self.path = path
		self.stereo = stereo
		self.resize = resize
		self.delay = delay
	
	def save(self, conflict_resolver):
		stereo = self.stereo.copy()
		stereo.split()
		def output_to_temp(output):
			base, ext = os.path.splitext(output.path)
			temp_path = tempfile.NamedTemporaryFile(suffix=ext, delete=False).name
			output.override_path(temp_path)
		map(output_to_temp, stereo.outputs)

		stereo.save(conflict_resolver = ConflictResolver.always(ConflictResolver.REPLACE))
		paths = [output.path for output in stereo.outputs]
		try:
			cmd = ['convert', '-delay', self.delay or '15', '-loop', '0']
			if self.resize:
				cmd.extend(['-resize', self.resize])
			cmd.extend(paths)
			cmd.append(self.path)
			resolve_path_clash(self.path, conflict_resolver)
			subprocess.check_call(cmd)
		finally:
			try:
				map(os.remove, paths)
			except StandardError, e:
				print >> sys.stderr, "Warning: could not remove files (%s): %r" % (e, paths)

class Gui(object):
	def __init__(self, image, opts):
		self.image = image
		self.opts = opts
		self.slice = opts.slice or 0
		self.align = opts.align or 0
		self.approved = False
	
	def display(self):
		from PIL import ImageTk
		image = self.update(self.image.copy())
		left, right = image.left, image.right
		blended = Image.blend(left, right, 0.5)
		blended.thumbnail((600,400))

		tk_img = ImageTk.PhotoImage(blended)
		self.label.configure(image = tk_img)
		self.label.image = tk_img
		self.label.update()
	
	def update(self, image):
		image.slice(self.slice)
		image.align(self.align)
		return image

	def run(self):
		#TODO: allow for re-ordering / adding / removing operations
		import Tkinter
		def quit(event):
			event.widget.quit()

		def accept(event):
			logging.debug("applying GUI changes to real image...")
			logging.info("accepted values:\n--slice=%s --align=%s" % (self.slice, self.align))
			self.update(self.image)
			self.approved = True
			quit(event)

		root = Tkinter.Tk()
		root.resizable(width=Tkinter.FALSE, height=Tkinter.FALSE)

		def align(amount):
			def action(*ignored):
				self.align += amount
				self.display()
			return action

		def slice(amount):
			def action(*ignored):
				self.slice += amount
				self.display()
			return action

		root.bind('<Escape>', quit)
		root.bind('<Return>', accept)

		def bind_arrows(up, down, left, right):
			just = lambda x: "<%s>" % (x,)
			shift = lambda x: just(x.upper()) if len(x) == 1 else "<Shift-%s>" % (x,)
			root.bind(just(up), align(1))
			root.bind(just(down), align(-1))
			root.bind(shift(up), align(0.1))
			root.bind(shift(down), align(-0.1))

			root.bind(just(left), slice(1))
			root.bind(just(right), slice(-1))
			root.bind(shift(left), slice(0.1))
			root.bind(shift(right), slice(-0.1))

		bind_arrows('Up','Down','Left','Right')
		bind_arrows('j','k','l','h')

		self.label = Tkinter.Label(root)
		self.label.pack()
		self.display()
		root.title(self.image.basename)
		root.mainloop()
		if not self.approved:
			raise SafeError("Cancelled.")

def main():
	from optparse import OptionParser, OptionGroup
	p = OptionParser("usage: %prog [OPTIONS] input1 [input2 [input3]]")
	p.add_option('-v', '--verbose', action='store_true')
	p.add_option('-f', '--force', help='replace existing files without asking', action='store_true')

	input_opts = OptionGroup(p, "Input / Output")
	input_opts.add_option('-l', '--left', help='inptut image (left)')
	input_opts.add_option('-r', '--right', help='inptut image (right)')
	input_opts.add_option('-o', '--suffix', help='output suffix')
	input_opts.add_option('-d', '--dest', help='destination directory')

	actions = OptionGroup(p, title="Image Actions")
	actions.add_option('--squash', action='append_const',   const='squash',   dest='actions', default=[], help='squash half vertically')
	actions.add_option('--split', action='append_const',    const='split',    dest='actions', help='split into left & right')
	actions.add_option('--merge', action='append_const',    const='merge',    dest='actions', help='merge left & right images')
	actions.add_option('--swap', action='append_const',     const='swap',     dest='actions', help='swap left & right')
	actions.add_option('--equalize', action='append_const', const='equalize', dest='actions', help='equalize brightness (auto brightness / contrast)')
	actions.add_option('--match', action='append_const',    const='match',    dest='actions', help='match left & right colours')
	actions.add_option('--animate', action='append_const',  const='animate',  dest='actions', help='make animated gif')

	gui_opts = OptionGroup(p, title="GUI Actions")
	gui_opts.add_option('-g', '--gui', help='modify slice / align interactively', action='store_true')
	gui_opts.add_option('--resize', help='(animation only) resize image to fit in rect (e.g "200x120")')
	gui_opts.add_option('--size', dest='resize', help='alias for --resize')
	gui_opts.add_option('--slice', default=0, type='int')
	gui_opts.add_option('--align', default=0, type='int')

	p.add_option_group(input_opts)
	p.add_option_group(actions)
	p.add_option_group(gui_opts)
	opts, args = p.parse_args()

	logging.basicConfig(level=logging.DEBUG if opts.verbose else logging.INFO, format="%(message)s")

	if opts.suffix:
		Stereo.suffix = opts.suffix

	if opts.dest:
		if not os.path.exists(opts.dest):
			logging.debug("creating %s" % (opts.dest,))
			os.makedirs(opts.dest)
		Stereo.dest = opts.dest

	conflict_resolver = ConflictResolver.prompt()
	if opts.force:
		conflict_resolver = ConflictResolver.always(ConflictResolver.REPLACE)
	#TODO: use a graphical conflict resolver for --gui

	def process(image):
		logging.info("Processing %s" % image.basename)
		for action in opts.actions:
			logging.debug("performing action: %s" % (action,))
			getattr(image, action)(opts)
			logging.debug("image -> %r" % (image,))
		if opts.gui:
			Gui(image, opts).run()
		image.save(conflict_resolver = conflict_resolver)

	if opts.left and opts.right:
		assert opts.left and opts.right
		process(Stereo.from_pair(opts.left, opts.right))
	else:
		assert not (opts.left or opts.right)
		assert len(args) > 0, "Please provide an input file! (or try --help)"
		for file in args:
			process(Stereo.from_single(file))
	
	assert len(opts.actions) > 0, "Please provide at least one action!"

if __name__ == '__main__':
	try:
		sys.exit(main())
	except (SafeError, AssertionError), e:
		print >> sys.stderr, e
		sys.exit(1)
	except (KeyboardInterrupt, EOFError):
		sys.exit(1)


